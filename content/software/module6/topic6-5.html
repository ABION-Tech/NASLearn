<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title> New Age Skillsphere</title>
  <!-- Bootstrap CSS -->
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="css\styles.css">

  <!-- Embedding CodeMirror (Code Editor) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.61.0/codemirror.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.61.0/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.61.0/mode/xml/xml.min.js"></script>
  <style>
    .container h1 {
      font-size: 2.3rem;
    }

    .CodeMirror {
      overflow: auto;
      min-width: 200px;
      resize: both;
      min-height: 150px;
      border: 1px solid #ccc;
      border-radius: 5px;
      width: 500px;
      height: 150px;
      margin-bottom: 15px;
    }

    /* Basic Reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* Body styles */
    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      top: 80px;
    }

    .container {
      padding: 20px;
    }

    /* Video container to hold everything */
    .video-container {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Gradient border container */
    .gradient-border {
      padding: 5px;
      background: linear-gradient(135deg, #3197eb, #ffffff, rgb(0, 174, 255));
      border-radius: 10px;
    }

    /* Video or content inside the border */
    .video-content {
      border-radius: 10px;
      display: block;
    }

    .video-links {
      color: grey;
      font-size: 0.8rem;
      text-align: center;
      margin-top: 5px;
    }

    /* Ensure responsive width and height for the video */
    iframe {
      width: 100%;
      height: 400px;
      border-radius: 10px;
    }

    body {
      background-color: #ffffff;
      color: #000000;
      font-family: Arial, sans-serif;
    }

    h1,
    h2,
    h3 {
      color: #007BFF;
      /* Blue accent */
    }

    .content-container {
      margin: 50px auto;
      max-width: 900px;
    }

    .custom-section {
      margin-bottom: 40px;
    }

    .custom-section p {
      line-height: 1.6;
      margin-bottom: 15px;
    }

    .custom-section ul {
      margin-left: 20px;
    }

    .custom-section ul li {
      margin-bottom: 10px;
    }

    blockquote {
      font-size: 1.1em;
      padding: 15px;
      border-left: 5px solid #007BFF;
      background-color: #f8f9fa;
    }

    /* Video container to hold everything */
    .video-container {
      display: flex;
      justify-content: center;
      align-items: center;
      padding-bottom: 100px;
    }

    /* Gradient border container */
    .gradient-border {
      padding: 5px;
      background: linear-gradient(135deg, #3197eb, #ffffff, rgb(0, 174, 255));
      border-radius: 10px;
    }

    /* Video or content inside the border */
    .video-content {
      border-radius: 10px;
      display: block;
    }

    .video-links {
      color: grey;
      font-size: 0.8rem;
      text-align: center;
      margin-top: 5px;
    }

    /* Ensure responsive width and height for the video */
    iframe {
      width: 100%;
      height: 400px;
      border-radius: 10px;
    }

    /* Responsiveness */
    @media (min-width: 1200px) {
      iframe {
        width: 800px;
        height: 450px;
      }
    }

    @media (max-width: 1200px) {
      iframe {
        width: 800px;
        height: 350px;
      }
    }

    @media (max-width: 768px) {
      iframe {
        width: 500px;
        height: 200px;
      }
    }

    /* For mobile screens, to avoid the box-like appearance */
    @media (max-width: 360px) {
      .video-content {
        width: 280px;
        /* Take full width */
        height: 200px;
        /* Adjust height to give a more rectangular shape */
      }

      /* For mobile screens, to avoid the box-like appearance */
      @media (max-width: 256px) {
        .video-content {
          width: 1080px;
          /* Take full width */
          height: 300px;
          /* Adjust height to give a more rectangular shape */
        }
      }
    }

    /* Responsiveness */
    @media (min-width: 1200px) {
      iframe {
        width: 800px;
        height: 450px;
      }
    }

    @media (max-width: 1200px) {
      iframe {
        width: 800px;
        height: 350px;
      }
    }

    @media (max-width: 768px) {
      iframe {
        width: 500px;
        height: 200px;
      }
    }

    /* For mobile screens, to avoid the box-like appearance */
    @media (max-width: 360px) {
      .video-content {
        width: 280px;
        /* Take full width */
        height: 200px;
        /* Adjust height to give a more rectangular shape */
      }

      /* For mobile screens, to avoid the box-like appearance */
      @media (max-width: 256px) {
        .video-content {
          width: 1080px;
          /* Take full width */
          height: 300px;
          /* Adjust height to give a more rectangular shape */
        }
      }
    }
  </style>

</head>


<body>
  <div class="container">
    <div class="header">
      <h1>Week 6: Advanced Python & Pythonic Programming</h1>
      <h2>6.5: Performance and Efficiency</h2>
    </div>

    <div class="module-content">
      <h2>Introduction: The Need for Speed and Efficiency</h2>
      <p>Writing code that works is the first step. Writing code that works efficiently is what separates a good
        developer from a great one. Performance optimization in Python isn't about micro-optimizing every line; it's
        about understanding the language's characteristics, identifying true bottlenecks, and applying the right
        strategies. This module covers the essential tools and techniques for making your Python code faster and more
        memory-efficient.</p>

      <h2>1. Profiling Python Code: Measure, Don't Guess</h2>
      <p>The golden rule of optimization is "Always profile before you optimize." Optimizing code you think is slow is a
        waste of time. Profiling provides hard data on where your program actually spends its time, allowing you to
        focus your efforts on the most impactful areas.</p>

      <div class="card">
        <div class="card-header">
          The 90/10 Rule
        </div>
        <div class="card-body">
          <p>Often, 90% of the execution time is spent in 10% of the code. Your goal is to find that critical 10%.</p>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          cProfile: Finding Bottlenecks
        </div>
        <div class="card-body">
          <p>cProfile is a powerful built-in module that provides a detailed report of how many times each function was
            called and how long it took.</p>
          <pre><code># profile_script.py
import cProfile
import re

def slow_function():
    # Simulate a slow operation
    total = 0
    for i in range(100000):
        total += i
    return total

def fast_function():
    return 42

def main():
    slow_function()
    fast_function()
    # Another common bottleneck: inefficient string operations
    text = "hello world " * 1000
    re.search(r'(a|b)+', text) # Inefficient regex

if __name__ == "__main__":
    # Run the profiler
    cProfile.run('main()', sort='cumulative') # Sort by total time in function</code></pre>
          <p>Run this from the command line: python profile_script.py The output shows a table with columns like:</p>
          <ul>
            <li><strong>ncalls:</strong> Number of calls.</li>
            <li><strong>tottime:</strong> Total time spent in the function (excluding sub-functions).</li>
            <li><strong>cumtime:</strong> Cumulative time spent in the function (including sub-functions). This is the
              most important column. You'll immediately see which functions are consuming the most time.</li>
          </ul>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          timeit: Micro-benchmarking Snippets
        </div>
        <div class="card-body">
          <p>For comparing small code snippets and getting precise timings, use the timeit module. It runs the code many
            times to get a reliable average.</p>
          <pre><code>import timeit

# Test the performance of list creation methods
time_list_comp = timeit.timeit('[x for x in range(1000)]', number=10000)
time_list_func = timeit.timeit('list(range(1000))', number=10000)

print(f"List comprehension: {time_list_comp:.4f} seconds")
print(f"list(range()): {time_list_func:.4f} seconds")</code></pre>
          <p>This is perfect for answering questions like "Is method A faster than method B?"</p>
        </div>
      </div>

      <div class="key-point">
        <h4>Key Takeaway</h4>
        <p>Never guess about performance. Use cProfile to find the slow parts of your entire application and timeit to
          compare specific alternatives.</p>
      </div>

      <h2>2. Generators: The Key to Memory Efficiency</h2>
      <p>For large datasets, memory usage can be a bigger problem than execution time. Generators are a Pythonic way to
        handle large sequences of data without loading them all into memory at once.</p>

      <div class="card">
        <div class="card-header">
          How Generators Work
        </div>
        <div class="card-body">
          <p>A generator function returns a special iterator, called a generator. It produces values one at a time, on
            demand, using the yield keyword. It pauses its state after each yield and resumes when the next value is
            requested.</p>
          <pre><code># This function creates a list of 1 million numbers in memory
def create_list(n):
    result = []
    for i in range(n):
        result.append(i)
    return result # All million numbers exist here

# This generator yields one number at a time, using almost no memory
def number_generator(n):
    for i in range(n):
        yield i # Pauses here after yielding each value

# Usage
my_list = create_list(1000000) # High memory usage!
my_gen = number_generator(1000000) # Very low memory usage

for num in my_gen: # Numbers are generated one by one in the loop
    if num > 10:
        break # We never generate the other 999,989 numbers!</code></pre>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          Generator Expressions
        </div>
        <div class="card-body">
          <p>Like list comprehensions, but for generators. They use parentheses instead of square brackets.</p>
          <pre><code># List comprehension - creates full list in memory
list_comp = [x*x for x in range(1000000)]

# Generator expression - creates a generator object
gen_exp = (x*x for x in range(1000000))

print(sum(gen_exp)) # Efficiently sums the values without building the list</code></pre>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          Real-World Use Case: Processing Large Files
        </div>
        <div class="card-body">
          <p>This is where generators shine. You can process files much larger than your available RAM.</p>
          <pre><code>def read_large_file(file_path):
    """Generator to yield one line from a file at a time."""
    with open(file_path, 'r') as file:
        for line in file:
            yield line.strip()

# Process a 50GB log file without loading it into memory
for line in read_large_file('huge_log_file.txt'):
    if 'ERROR' in line:
        print(line)
    # Process the line</code></pre>
        </div>
      </div>

      <div class="key-point">
        <h4>Key Takeaway</h4>
        <p>Use generators and generator expressions for large data streams or when you might not need to process all
          elements. They dramatically reduce memory footprint and can improve performance by allowing early termination.
        </p>
      </div>

      <h2>3. Just-in-Time (JIT) Compilation: The Nuclear Option</h2>
      <p>The standard Python interpreter (CPython) is slow for certain tasks, especially tight numerical loops. A
        Just-in-Time (JIT) compiler can translate parts of your Python code to fast machine code at runtime, offering
        massive speedups.</p>

      <div class="card">
        <div class="card-header">
          CPython (The Standard)
        </div>
        <div class="card-body">
          <p>The reference implementation of Python. It interprets your code or runs pre-compiled bytecode. It's simple
            and robust but not built for raw speed.</p>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          PyPy: A Fast Alternative Interpreter
        </div>
        <div class="card-body">
          <p>PyPy is a JIT compiler that is a drop-in replacement for CPython. For long-running programs (like web
            servers) with predictable types, it can provide significant speedups (often 5x-10x) with no code changes.
          </p>
          <p><strong>How to use it:</strong> Install PyPy (pypy3), and run your script with it instead of python3.</p>
          <p><strong>Best for:</strong> Pure Python applications that are CPU-bound and don't rely heavily on C
            extensions (like NumPy) that are optimized for CPython.</p>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          Numba: JIT for Scientific Python
        </div>
        <div class="card-body">
          <p>Numba is a library that compiles Python functions to machine code using the LLVM compiler. Its beauty is
            that you can often add a simple decorator to a function for a huge speedup.</p>
          <pre><code>import numba
import numpy as np

# A slow, pure Python function for a numerical calculation
def slow_sum(arr):
    total = 0.0
    for item in arr:
        total += item
    return total

# The same function, JIT-compiled with Numba
@numba.jit(nopython=True) # nopython=True means "compile entirely to machine code"
def fast_sum(arr):
    total = 0.0
    for item in arr:
        total += item
    return total

# Create a large array
large_array = np.random.random(10_000_000)

# Time the functions
%timeit slow_sum(large_array) # May take ~100s of ms
%timeit fast_sum(large_array) # Will take a few ms - orders of magnitude faster!</code></pre>
          <p><strong>Best for:</strong> NumPy code and mathematical functions with loops. It's ideal for data science
            and scientific computing.</p>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          A Word of Caution
        </div>
        <div class="card-body">
          <p>JIT compilers are powerful but are not magic. They work best on code with predictable data types (like
            numbers in loops) and can add overhead for very short functions. The best first step is always to write
            efficient algorithms and data structures in pure Python before reaching for a JIT.</p>
        </div>
      </div>

      <h2>Module 6.5 Summary:</h2>

      <table class="custom-table">
        <thead>
          <tr>
            <th>Concept</th>
            <th>Core Idea</th>
            <th>When to Use</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Profiling (cProfile, timeit)</strong></td>
            <td>Measure performance to find real bottlenecks, not perceived ones.</td>
            <td>Always. Before writing a single line of optimized code, profile your application.</td>
          </tr>
          <tr>
            <td><strong>Generators (yield)</strong></td>
            <td>Produce items one at a time, on demand, saving memory.</td>
            <td>When working with large datasets, streams, or files that don't fit in memory.</td>
          </tr>
          <tr>
            <td><strong>JIT Compilation (PyPy, Numba)</strong></td>
            <td>Translate Python bytecode to fast machine code at runtime.</td>
            <td>PyPy: For long-running, CPU-bound pure Python apps.<br>Numba: For numerical computations, especially
              with NumPy and loops.</td>
          </tr>
        </tbody>
      </table>

      <div class="key-point">
        <h4>Final Takeaway</h4>
        <p>Writing efficient Python is a multi-stage process:</p>
        <ol>
          <li>Write clean, Pythonic code with the right algorithms and data structures.</li>
          <li>Profile your code to identify the true bottlenecks.</li>
          <li>Apply targeted optimizations: Use generators for memory, leverage built-in functions for speed, and
            consider JIT compilers (Numba) for numerical work.</li>
          <li>Never sacrifice readability for a minor speed gain. Clarity is almost always more important than speed in
            Python. Only optimize the parts that profiling proves are slow.</li>
        </ol>
      </div>
    </div>
  </div>

  <!-- 
  <div class="video-container">
    <div class="gradient-border">
      <iframe class="video-content" src="https://www.youtube.com/embed/OyEHnIC45Zk" frameborder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
        allowfullscreen>
      </iframe>
      <div class="video-links">
        <h4>Channel Name<h4>
      </div>
    </div>
  </div> -->
</body>


</html>