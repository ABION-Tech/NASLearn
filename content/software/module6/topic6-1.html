<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title> New Age Skillsphere</title>
  <!-- Bootstrap CSS -->
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="css\styles.css">

  <!-- Embedding CodeMirror (Code Editor) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.61.0/codemirror.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.61.0/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.61.0/mode/xml/xml.min.js"></script>
  <style>
    .container h1 {
      font-size: 2.3rem;
    }

    .CodeMirror {
      overflow: auto;
      min-width: 200px;
      resize: both;
      min-height: 150px;
      border: 1px solid #ccc;
      border-radius: 5px;
      width: 500px;
      height: 150px;
      margin-bottom: 15px;
    }

    /* Basic Reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* Body styles */
    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      top: 80px;
    }

    .container {
      padding: 20px;
    }

    /* Video container to hold everything */
    .video-container {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Gradient border container */
    .gradient-border {
      padding: 5px;
      background: linear-gradient(135deg, #3197eb, #ffffff, rgb(0, 174, 255));
      border-radius: 10px;
    }

    /* Video or content inside the border */
    .video-content {
      border-radius: 10px;
      display: block;
    }

    .video-links {
      color: grey;
      font-size: 0.8rem;
      text-align: center;
      margin-top: 5px;
    }

    /* Table Styling */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }

    th,
    td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: left;
    }

    th {
      background-color: #007BFF;
      color: white;
    }

    .card-header {
      background-color: #007BFF;
      color: rgb(255, 255, 255)
    }

    /* Ensure responsive width and height for the video */
    iframe {
      width: 100%;
      height: 400px;
      border-radius: 10px;
    }

    body {
      background-color: #ffffff;
      color: #000000;
      font-family: Arial, sans-serif;
    }

    h1,
    h2,
    h3 {
      color: #007BFF;
      /* Blue accent */
    }

    .content-container {
      margin: 50px auto;
      max-width: 900px;
    }

    .custom-section {
      margin-bottom: 40px;
    }

    .custom-section p {
      line-height: 1.6;
      margin-bottom: 15px;
    }

    .custom-section ul {
      margin-left: 20px;
    }

    .custom-section ul li {
      margin-bottom: 10px;
    }

    blockquote {
      font-size: 1.1em;
      padding: 15px;
      border-left: 5px solid #007BFF;
      background-color: #f8f9fa;
    }

    /* Video container to hold everything */
    .video-container {
      display: flex;
      justify-content: center;
      align-items: center;
      padding-bottom: 100px;
    }

    /* Gradient border container */
    .gradient-border {
      padding: 5px;
      background: linear-gradient(135deg, #3197eb, #ffffff, rgb(0, 174, 255));
      border-radius: 10px;
    }

    /* Video or content inside the border */
    .video-content {
      border-radius: 10px;
      display: block;
    }

    .video-links {
      color: grey;
      font-size: 0.8rem;
      text-align: center;
      margin-top: 5px;
    }

    /* Ensure responsive width and height for the video */
    iframe {
      width: 100%;
      height: 400px;
      border-radius: 10px;
    }

    /* Responsiveness */
    @media (min-width: 1200px) {
      iframe {
        width: 800px;
        height: 450px;
      }
    }

    @media (max-width: 1200px) {
      iframe {
        width: 800px;
        height: 350px;
      }
    }

    @media (max-width: 768px) {
      iframe {
        width: 500px;
        height: 200px;
      }
    }

    /* For mobile screens, to avoid the box-like appearance */
    @media (max-width: 360px) {
      .video-content {
        width: 280px;
        /* Take full width */
        height: 200px;
        /* Adjust height to give a more rectangular shape */
      }

      /* For mobile screens, to avoid the box-like appearance */
      @media (max-width: 256px) {
        .video-content {
          width: 1080px;
          /* Take full width */
          height: 300px;
          /* Adjust height to give a more rectangular shape */
        }
      }
    }

    /* Responsiveness */
    @media (min-width: 1200px) {
      iframe {
        width: 800px;
        height: 450px;
      }
    }

    @media (max-width: 1200px) {
      iframe {
        width: 800px;
        height: 350px;
      }
    }

    @media (max-width: 768px) {
      iframe {
        width: 500px;
        height: 200px;
      }
    }

    /* For mobile screens, to avoid the box-like appearance */
    @media (max-width: 360px) {
      .video-content {
        width: 280px;
        /* Take full width */
        height: 200px;
        /* Adjust height to give a more rectangular shape */
      }

      /* For mobile screens, to avoid the box-like appearance */
      @media (max-width: 256px) {
        .video-content {
          width: 1080px;
          /* Take full width */
          height: 300px;
          /* Adjust height to give a more rectangular shape */
        }
      }
    }
  </style>

</head>


<body>
  <div class="container">
    <div class="header">
      <h1>6.1: The Python Data Model & Special Methods</h1>
    </div>

    <div class="module-content">
      <h2>Introduction: The Philosophy of Pythonic Code</h2>
      <p>Python's simplicity and power don't just come from its syntax, but from a deep, consistent design philosophy.
        This philosophy is encapsulated in the Python Data Modelâ€”the formal description of the interfaces that make your
        objects work seamlessly with the language's core features. Mastering this is the key to transitioning from
        writing code that works in Python to writing code that is idiomatic or Pythonic.</p>

      <h2>1. Understanding Dunder Methods: The Language of the Data Model</h2>
      <p>Dunder methods (short for "double underscore") are special methods that Python uses to provide a consistent
        interface for its built-in operations. They are the mechanism that allows your custom objects to behave like
        native Python types (e.g., list, str, dict).</p>

      <div class="card">
        <div class="card-header">
          Key Dunder Methods
        </div>
        <div class="card-body">
          <ul>
            <li><strong>__init__(self, [...]):</strong> The object initializer, not the constructor. It is called after
              the object has been created (__new__) to set its initial state.
              <ul>
                <li><strong>Common Mistake:</strong> It does not return a value. Its job is to populate the newly
                  created self.</li>
              </ul>
            </li>
            <li><strong>__str__(self) vs. __repr__(self):</strong> This is a crucial distinction.
              <ul>
                <li><strong>__str__(self):</strong> Purpose is readability. It returns a human-friendly, informal string
                  representation of the object. It's called by print(), str(), and formatting functions like f-strings.
                </li>
                <li><strong>__repr__(self):</strong> Purpose is unambiguity. It should return a more formal,
                  developer-focused string that ideally could be used to recreate the object. It's a fallback for
                  __str__ and is called by the REPL and the repr() built-in.</li>
                <li><strong>The Golden Rule:</strong> __repr__ is for developers, __str__ is for users. If you can only
                  implement one, implement __repr__, as it's more widely used for debugging.</li>
              </ul>
            </li>
            <li><strong>__len__(self):</strong> Allows an object to work with the len() built-in function. It should
              return a non-negative integer representing the object's "length."</li>
          </ul>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          Deep Dive Example: The Book Class
        </div>
        <div class="card-body">
          <pre><code>class Book:
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages
    def __repr__(self):
        # Aim to be unambiguous. This looks like a valid Python expression.
        return f"Book('{self.title}', '{self.author}', {self.pages})"
    def __str__(self):
        # Aim to be readable for an end-user.
        return f"'{self.title}' by {self.author}"
    def __len__(self):
        # Define the "length" of a book as its page count.
        return self.pages
# Using the class
my_book = Book("Fluent Python", "Luciano Ramalho", 600)
print(repr(my_book))  # Output: Book('Fluent Python', 'Luciano Ramalho', 600)
print(str(my_book))   # Output: 'Fluent Python' by Luciano Ramalho
print(len(my_book))   # Output: 600</code></pre>
          <p>Now, Book objects integrate naturally with Python's ecosystem. The len() function "just works."</p>
        </div>
      </div>

      <h2>2. Making Objects Behave Like Built-ins: Emulating Types</h2>
      <p>The real power of the Data Model is that it allows you to make your custom objects feel like native Python
        types. This is achieved by implementing sequences of related dunder methods.</p>

      <div class="card">
        <div class="card-header">
          Making an Object Indexable (like a list or dict)
        </div>
        <div class="card-body">
          <ul>
            <li><strong>__getitem__(self, key):</strong> Enables using the obj[key] syntax for accessing elements.</li>
            <li><strong>__setitem__(self, key, value):</strong> Enables using the obj[key] = value syntax for assigning
              values.</li>
          </ul>
          <p><strong>Example: A simple, custom bookshelf.</strong></p>
          <pre><code>class Bookshelf:
    def __init__(self):
        self.books = []
    def __getitem__(self, index):
        # This enables indexing: shelf[0], slicing: shelf[1:3], and iteration.
        return self.books[index]
    def __setitem__(self, index, value):
        self.books[index] = value
    def __len__(self):
        return len(self.books)
    def add_book(self, book):
        self.books.append(book)
shelf = Bookshelf()
shelf.add_book(my_book)
shelf.add_book(Book("Python Crash Course", "Eric Matthes", 500))
print(shelf[0])       # Output: 'Fluent Python' by Luciano Ramalho (uses __str__)
print(len(shelf))     # Output: 2
for book in shelf:    # Iteration works because of __getitem__ and __len__!
    print(book)</code></pre>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          Making an Object Iterable (like a for loop target)
        </div>
        <div class="card-body">
          <p><strong>The Iterator Protocol:</strong> To make an object iterable, it must implement __iter__(). This
            method must return an iterator object. An iterator object must implement __next__(), which returns the next
            item or raises StopIteration.</p>
          <p><strong>Simpler Way:</strong> Often, __iter__ can be a generator function using yield.</p>
          <pre><code>class Library:
    def __init__(self):
        self.bookshelf = Bookshelf()
    def __iter__(self):
        # This makes the Library instance itself iterable.
        # We yield from the bookshelf's iterator, delegating the work.
        yield from self.bookshelf
        # This is equivalent to:
        # for book in self.bookshelf:
        #     yield book
lib = Library()
# ... add books to lib.bookshelf
for book in lib: # This works because of __iter__
    print(book)</code></pre>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          Overloading Operators (like numbers)
        </div>
        <div class="card-body">
          <ul>
            <li><strong>__add__(self, other):</strong> Enables the + operator (obj + other).</li>
            <li><strong>__mul__(self, other):</strong> Enables the * operator (obj * other).</li>
          </ul>
          <p><strong>Example: Adding two vectors.</strong></p>
          <pre><code>class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"
    def __add__(self, other):
        # Define what it means to add two Vectors
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        else:
            return NotImplemented # Tell Python we can't handle this type
    def __mul__(self, scalar):
        # Define what it means to multiply a Vector by a number (scalar)
        if isinstance(scalar, (int, float)):
            return Vector(self.x * scalar, self.y * scalar)
        else:
            return NotImplemented
v1 = Vector(2, 4)
v2 = Vector(1, 3)
print(v1 + v2)  # Output: Vector(3, 7)
print(v1 * 3)   # Output: Vector(6, 12)</code></pre>
        </div>
      </div>

      <h2>3. Protocols in Python: Duck Typing Formalized</h2>
      <p>A protocol is an informal interface. It's a set of methods that, if your object implements them, it will
        automatically gain a certain behavior. This is the essence of duck typing ("if it walks like a duck and quacks
        like a duck, it's a duck").</p>

      <div class="card">
        <div class="card-header">
          Key Insight
        </div>
        <div class="card-body">
          <p>You don't need to inherit from a specific abstract base class to have a certain functionality. You just
            need to implement the required methods.</p>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          Common Protocols
        </div>
        <div class="card-body">
          <ul>
            <li><strong>The Sequence Protocol:</strong> To behave like a sequence (list, tuple), an object should
              implement:
              <ul>
                <li>__len__</li>
                <li>__getitem__</li>
                <li>(Optionally) __contains__, __iter__, __reversed__</li>
              </ul>
              Our Bookshelf class above implicitly follows the sequence protocol. Python sees it has __len__ and
              __getitem__ and treats it like a sequence, allowing iteration, the in keyword, and slicing.
            </li>
            <li><strong>The Iterator Protocol:</strong> As discussed, this requires:
              <ul>
                <li>__iter__: Returns the iterator object (often self).</li>
                <li>__next__: Returns the next value.</li>
              </ul>
            </li>
            <li><strong>The Context Manager Protocol:</strong> (For use with with statements)
              <ul>
                <li>__enter__(self)</li>
                <li>__exit__(self, exc_type, exc_val, exc_tb)</li>
              </ul>
              Implementing these two methods allows your object to manage resources cleanly.
            </li>
          </ul>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          Why Protocols are Powerful
        </div>
        <div class="card-body">
          <p>They promote loose coupling and are incredibly flexible. A function written to accept any "sequence"
            doesn't care if it's a list, a tuple, a NumPy array, or your custom Bookshelf class. It will work with any
            object that implements the sequence protocol.</p>
        </div>
      </div>

      <h2>Module 6.1 Summary:</h2>

      <table class="custom-table">
        <thead>
          <tr>
            <th>Concept</th>
            <th>Core Idea</th>
            <th>Pythonic Principle</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Dunder Methods</strong></td>
            <td>Special methods that hook into Python's syntax.</td>
            <td>They allow your objects to integrate seamlessly with the language.</td>
          </tr>
          <tr>
            <td><strong>__str__ vs __repr__</strong></td>
            <td>Readability vs. Unambiguity.</td>
            <td>__repr__ is for developers; __str__ is for users.</td>
          </tr>
          <tr>
            <td><strong>Emulating Types</strong></td>
            <td>Use dunder methods to make objects indexable, iterable, etc.</td>
            <td>Don't create cumbersome get_length() methods; implement __len__ and use len(obj).</td>
          </tr>
          <tr>
            <td><strong>Protocols</strong></td>
            <td>Informal interfaces defined by methods, not inheritance.</td>
            <td>This is "duck typing." Code to interfaces (expected methods), not specific classes.</td>
          </tr>
        </tbody>
      </table>

      <div class="key-point">
        <h4>Key Takeaway</h4>
        <p>The Python Data Model is the framework that makes the language so consistent and powerful. By understanding
          and using dunder methods, you write code that is more intuitive, reusable, and beautifully integrated into
          Python itself. This is the foundation of writing truly Pythonic code.</p>
      </div>
    </div>
  </div>

  <!-- 
  <div class="video-container">
    <div class="gradient-border">
      <iframe class="video-content" src="https://www.youtube.com/embed/OyEHnIC45Zk" frameborder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
        allowfullscreen>
      </iframe>
      <div class="video-links">
        <h4>Channel Name<h4>
      </div>
    </div>
  </div> -->


</body>


</html>